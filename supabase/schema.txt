-- Enable the pgvector extension to work with embeddings
create extension if not exists vector;

-- Create Documents Table
create table if not exists documents (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text not null,
  type text,
  summary text,
  event_date date,
  expiry_date date,
  extracted_data jsonb,
  risk_analysis jsonb,
  file_path text,
  user_id uuid
);

-- Create Reminders Table
create table if not exists reminders (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  document_id uuid references documents(id) on delete cascade,
  title text not null,
  date date,
  time text,
  priority text,
  source text default 'document' -- 'document' or 'manual'
);

-- Create Vector Store Table (for RAG/Smart Search)
create table if not exists document_chunks (
  id uuid default gen_random_uuid() primary key,
  document_id uuid references documents(id) on delete cascade,
  content text,
  embedding vector(768) -- Matches Gemini text-embedding-004 dimension
);

-- ENABLE ROW LEVEL SECURITY (RLS)
alter table documents enable row level security;
alter table reminders enable row level security;
alter table document_chunks enable row level security;

-- CREATE POLICIES (PERMISSIVE FOR PROTOTYPE)
-- IMPORTANT: In a real production app with Auth, you would change 'true' to 'auth.uid() = user_id'

-- Documents Policies
create policy "Enable all access for all users" on documents
for all using (true) with check (true);

-- Reminders Policies
create policy "Enable all access for all users" on reminders
for all using (true) with check (true);

-- Chunks Policies
create policy "Enable all access for all users" on document_chunks
for all using (true) with check (true);

-- STORAGE BUCKET SETUP (Optional via SQL, usually done in Dashboard UI)
-- Attempt to create a public bucket named 'documents'
insert into storage.buckets (id, name, public)
values ('documents', 'documents', true)
on conflict (id) do nothing;

create policy "Public Access" on storage.objects for select
using ( bucket_id = 'documents' );

create policy "Public Upload" on storage.objects for insert
with check ( bucket_id = 'documents' );
